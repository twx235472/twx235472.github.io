<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贝贝的小屋</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-11T11:59:23.952Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>钢铁雷诺</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty系列1——NIO</title>
    <link href="http://yoursite.com/2020/09/30/netty_1_NIO/"/>
    <id>http://yoursite.com/2020/09/30/netty_1_NIO/</id>
    <published>2020-09-30T03:03:41.000Z</published>
    <updated>2020-10-11T11:59:23.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h1><h3 id="一-常见的三种I-O模型"><a href="#一-常见的三种I-O模型" class="headerlink" title="一.  常见的三种I/O模型"></a>一.  常见的三种I/O模型</h3><ol><li><p>什么是I/O模型</p><p>In and out，顾名思义就是说程序的输入输出口，负责程序接受或发送信息</p></li><li><p>常见的三种I/O模型</p><p>我这网上看到说的I/O模型有5种，这里介绍主要的三种模型：BIO，NIO，AIO</p><ul><li><p>BIO（Blocking IO）</p><p>用户每次IO请求发起以后，直接被阻塞，直到完成请求任务以后，整个系统才会继续运行。（你不回答，我就一直等着呗）</p></li><li><p>NIO（nonblocking IO）</p><p>用户每次IO请求发起以后，不阻塞，服务端直接返回结果，用户持续轮询，直到连接完成为止。（你每次都直接回答，我在试试</p><p>）</p></li><li><p>AIO（asynchronous IO）</p><p>用户IO请求发起以后，不管服务是否返回，用户都不管，直接继续自己的事情</p></li></ul></li></ol><a id="more"></a><h3 id="二-BIO模型简述"><a href="#二-BIO模型简述" class="headerlink" title="二. BIO模型简述"></a>二. BIO模型简述</h3><ol><li><p>BIO模型的结构</p><p><img src="https://s1.ax1x.com/2020/10/11/0gZ1cd.png" alt="BIO"></p><p>简单来说，就是一个线程处理一个客户端请求，当有多用户接入的时候，就需要多个线程来支撑。如果该线程没有任务可做，就会阻塞在那</p><p>（自己实验了一下，简单写一个阻塞模式的服务端并打印线程ID，确实是一个链接对应一个线程）</p></li><li><p>BIO模型的问题</p><ul><li>客户端较多时，需要很多线程来支撑</li><li>当链接没有任务可做时，会直接阻塞，浪费资源</li></ul></li></ol><h3 id="三-NIO模型详解"><a href="#三-NIO模型详解" class="headerlink" title="三. NIO模型详解"></a>三. NIO模型详解</h3><ol><li><p>NIO模型的结构</p><p><img src="https://s1.ax1x.com/2020/10/11/0gZ3jA.png"></p><p>NIO采用的select的模式，多个连接由一个selector来管理，只需要一个线程就能处理多个连接，采用轮询的方式一次处理每个连接的事件，如果某个链接没有事件就立刻返回。</p></li><li><p>NIO重要组件：</p><p><img src="https://s1.ax1x.com/2020/10/11/0gebss.png"></p><ol><li><p>Buffer（缓冲区）</p><ul><li>IO过程的数据必须经过buffer来读/写</li><li>ByteBuffer是buffer的其中一种，类似于结构体，支持类类型化的put，get，put的类型和get的类型要一直，不然很有可能导致乱编码</li><li>ByteBuffer可以设置只读</li><li>每次使用完成Buffer以后，最好使用flip()时得position重新回到起始位置，每次操作都会使得position向前移动</li><li>MappedByteBuffer，可以让文件直接在内存（堆外内存）修改，操作系统不需要拷贝一次</li><li>Buffer数据支持分散和聚集，分散可以理解为数据按照顺序写入数组的每一个buffer中去，聚集可以理解为可以直接操纵这个数组变量依次读取数组中每一个成员的数据</li></ul></li><li><p>channel</p><p>可以理解为一个双向连接通道，既可以读取也可以写，不像流只能读或者</p></li><li><p>selector</p><p>selector能够检测多个注册的通道上是否有事件发送（多个channel以事件的方式注册到同一个selector），如果有事件发生，就直接获取事件并做后续处理</p></li></ol></li></ol><h3 id="四-小型聊天室案例"><a href="#四-小型聊天室案例" class="headerlink" title="四. 小型聊天室案例"></a>四. 小型聊天室案例</h3><p>​    通过一个简陋的聊天室的案例来使用具体说明使用方式，因为NIO不是学习的重点，这里就简单写一个，为后面学习netty做一个背景铺垫</p><ol><li><p>需求</p><ul><li>编写一个NIO群聊，实现服务端和客户端之间的简单通讯</li><li>实现多人群聊</li><li>服务端：可以检测用户上线，离线，并实现消息转发功能</li><li>客户端：通过channel可以无阻塞发送消息给其他用户，同时可以接受其他用户发送的消息</li></ul></li><li><p>服务端实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NIOChatRoomServer &#123;</span><br><span class="line"></span><br><span class="line">    private Selector selector;</span><br><span class="line">    private ServerSocketChannel serverSocketChannel;</span><br><span class="line">    private InetSocketAddress inetSocketAddress;</span><br><span class="line">    private final static Integer port &#x3D; 6666;</span><br><span class="line"></span><br><span class="line">    public NIOChatRoomServer()&#123;</span><br><span class="line">        &#x2F;&#x2F;初始化</span><br><span class="line">        try &#123;</span><br><span class="line">            serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">            inetSocketAddress &#x3D; new InetSocketAddress(port);</span><br><span class="line">            serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">            selector &#x3D; Selector.open();</span><br><span class="line"></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);    &#x2F;&#x2F;服务端需要监听accept事件，所以注册到selector中</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;finish the server init!.....&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen()&#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int select &#x3D; selector.select(1000);</span><br><span class="line">                if(select &gt; 0)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();</span><br><span class="line">                    while(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey next &#x3D; iterator.next();</span><br><span class="line">                        if(next.isAcceptable())&#123;</span><br><span class="line">                            SocketChannel accept &#x3D; serverSocketChannel.accept();</span><br><span class="line">                            accept.configureBlocking(false);</span><br><span class="line">                            accept.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                            String msg &#x3D; &quot;client &quot;+accept.getRemoteAddress()+&quot; connect!...&quot;;</span><br><span class="line">                            System.out.println(msg);</span><br><span class="line">                            sendMsgToOther(msg,accept);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(next.isReadable())&#123;</span><br><span class="line">                            SocketChannel channel &#x3D; null;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                &#x2F;&#x2F;read msg</span><br><span class="line">                                channel &#x3D; (SocketChannel)next.channel();</span><br><span class="line">                                ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                                int read &#x3D; channel.read(byteBuffer);</span><br><span class="line">                                if(read &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                                    System.out.println(&quot;disconnect  &quot;+channel.getRemoteAddress());</span><br><span class="line">                                    String str &#x3D; new String(channel.getRemoteAddress()+&quot; disconnect!&quot;);</span><br><span class="line">                                    sendMsgToOther(str,channel);</span><br><span class="line">                                    next.cancel();</span><br><span class="line">                                    channel.close();</span><br><span class="line">                                &#125;</span><br><span class="line">                                String msg &#x3D; new String(byteBuffer.array());</span><br><span class="line">                                System.out.println(&quot;get msg from &quot;+channel.getRemoteAddress()+&quot; msg is:&quot;+msg);</span><br><span class="line"></span><br><span class="line">                                &#x2F;&#x2F;send msg to other client</span><br><span class="line">                                sendMsgToOther(msg,channel);</span><br><span class="line">                            &#125;catch (IOException e)&#123;</span><br><span class="line">                                System.out.println(&quot;disconnect  &quot;+channel.getRemoteAddress());</span><br><span class="line">                                String str &#x3D; new String(channel.getRemoteAddress()+&quot; disconnect!&quot;);</span><br><span class="line">                                sendMsgToOther(str,channel);</span><br><span class="line">                                next.cancel();</span><br><span class="line">                                next.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;转发消息</span><br><span class="line">    public void sendMsgToOther(String msg,SocketChannel self) throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;send msg to other client&quot;);</span><br><span class="line">        String info &#x3D; self.getRemoteAddress() +&quot; say: &quot;+msg;</span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; keys &#x3D; selector.keys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator &#x3D; keys.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            SelectionKey next &#x3D; iterator.next();</span><br><span class="line">            Channel channel &#x3D; next.channel();</span><br><span class="line">            if(channel instanceof SocketChannel &amp;&amp; channel !&#x3D; self)&#123;</span><br><span class="line">                &#x2F;&#x2F;send to them</span><br><span class="line">                ((SocketChannel) channel).write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NIOChatRoomServer nioChatRoomServer &#x3D; new NIOChatRoomServer();</span><br><span class="line">        nioChatRoomServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>客户端实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectableChannel;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NioChatRoomClient &#123;</span><br><span class="line"></span><br><span class="line">    private Selector selector;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line">    private static final InetSocketAddress address &#x3D; new InetSocketAddress(&quot;127.0.0.1&quot;,6666);</span><br><span class="line"></span><br><span class="line">    public NioChatRoomClient()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            selector &#x3D; Selector.open();</span><br><span class="line">            socketChannel &#x3D; SocketChannel.open(address);</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ); &#x2F;&#x2F;因为需要接受服务端发送的其他人的消息，所以这里需要监听一个读事件</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String msg) throws Exception&#123;</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reciveMsg() throws Exception&#123;</span><br><span class="line">            int select &#x3D; selector.select(1000);</span><br><span class="line">            if (select &gt; 0)&#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();</span><br><span class="line">                while (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey next &#x3D; iterator.next();</span><br><span class="line">                    if (next.isReadable())&#123;</span><br><span class="line">                        SocketChannel channel &#x3D; (SocketChannel)next.channel();</span><br><span class="line">                        channel.configureBlocking(false);</span><br><span class="line">                        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                        int read &#x3D; channel.read(byteBuffer);</span><br><span class="line">                        if(read &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                            System.out.println(&quot;disconnnect from server!&quot;);</span><br><span class="line">                            next.cancel();</span><br><span class="line">                            next.channel().close();</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(channel.getRemoteAddress() +&quot; say:&quot; + new String(byteBuffer.array()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        NioChatRoomClient nioChatRoomClient &#x3D; new NioChatRoomClient();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        nioChatRoomClient.reciveMsg();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.currentThread().sleep(3000);</span><br><span class="line">                    &#125;catch (Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNextLine())&#123;</span><br><span class="line">            String s &#x3D; scanner.nextLine();</span><br><span class="line">            nioChatRoomClient.sendMsg(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>感受：直接用NIO来写服务端和客户端有点难受，API不友好且不够智能，有点类似于之前写C++的socket一样，为了然自己更舒服，后面就有人开发了Netty，这个就是基于NIO做了封装，并且二次开发以后的产物，后续会说到。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NIO模型&quot;&gt;&lt;a href=&quot;#NIO模型&quot; class=&quot;headerlink&quot; title=&quot;NIO模型&quot;&gt;&lt;/a&gt;NIO模型&lt;/h1&gt;&lt;h3 id=&quot;一-常见的三种I-O模型&quot;&gt;&lt;a href=&quot;#一-常见的三种I-O模型&quot; class=&quot;headerlink&quot; title=&quot;一.  常见的三种I/O模型&quot;&gt;&lt;/a&gt;一.  常见的三种I/O模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是I/O模型&lt;/p&gt;
&lt;p&gt;In and out，顾名思义就是说程序的输入输出口，负责程序接受或发送信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的三种I/O模型&lt;/p&gt;
&lt;p&gt;我这网上看到说的I/O模型有5种，这里介绍主要的三种模型：BIO，NIO，AIO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BIO（Blocking IO）&lt;/p&gt;
&lt;p&gt;用户每次IO请求发起以后，直接被阻塞，直到完成请求任务以后，整个系统才会继续运行。（你不回答，我就一直等着呗）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NIO（nonblocking IO）&lt;/p&gt;
&lt;p&gt;用户每次IO请求发起以后，不阻塞，服务端直接返回结果，用户持续轮询，直到连接完成为止。（你每次都直接回答，我在试试&lt;/p&gt;
&lt;p&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AIO（asynchronous IO）&lt;/p&gt;
&lt;p&gt;用户IO请求发起以后，不管服务是否返回，用户都不管，直接继续自己的事情&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty系列2——线程模型</title>
    <link href="http://yoursite.com/2020/09/30/netty_2_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/09/30/netty_2_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-09-30T03:03:41.000Z</published>
    <updated>2020-10-11T11:59:24.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程模型可以大致分为三种：一对一，一对多，多对多。三种类型各有各的好处，这里为了更好的理解netty的架构设计，所以单独先延伸学习一下这部分。总的来说，以上说的三种情况</p><a id="more"></a><h2 id="1-1-传统的IO线程模型（一对一）"><a href="#1-1-传统的IO线程模型（一对一）" class="headerlink" title="1.1 传统的IO线程模型（一对一）"></a>1.1 传统的IO线程模型（一对一）</h2><p><img src="https://s1.ax1x.com/2020/10/11/0g30o9.png"></p><h2 id="1-2-reactor-线程模型"><a href="#1-2-reactor-线程模型" class="headerlink" title="1.2 reactor 线程模型"></a>1.2 reactor 线程模型</h2><h3 id="1-2-1-单reactor单线程（一对一）"><a href="#1-2-1-单reactor单线程（一对一）" class="headerlink" title="1.2.1 单reactor单线程（一对一）"></a>1.2.1 单reactor单线程（一对一）</h3><p><img src="https://s1.ax1x.com/2020/10/11/0g3qOS.png"></p><h3 id="1-2-2-单reactor多线程（一对多）"><a href="#1-2-2-单reactor多线程（一对多）" class="headerlink" title="1.2.2 单reactor多线程（一对多）"></a>1.2.2 单reactor多线程（一对多）</h3><p><img src="https://s1.ax1x.com/2020/10/11/0g8ClV.png"></p><h3 id="1-2-3-多reactor多线程（三层结构，多对多）"><a href="#1-2-3-多reactor多线程（三层结构，多对多）" class="headerlink" title="1.2.3 多reactor多线程（三层结构，多对多）"></a>1.2.3 多reactor多线程（三层结构，多对多）</h3><p><img src="https://s1.ax1x.com/2020/10/11/0g8Zk9.png"></p><h3 id="1-3-netty的线程模型"><a href="#1-3-netty的线程模型" class="headerlink" title="1.3 netty的线程模型"></a>1.3 netty的线程模型</h3><p><img src="https://s1.ax1x.com/2020/10/11/0g87N9.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程模型&quot;&gt;&lt;a href=&quot;#线程模型&quot; class=&quot;headerlink&quot; title=&quot;线程模型&quot;&gt;&lt;/a&gt;线程模型&lt;/h1&gt;&lt;p&gt;线程模型可以大致分为三种：一对一，一对多，多对多。三种类型各有各的好处，这里为了更好的理解netty的架构设计，所以单独先延伸学习一下这部分。总的来说，以上说的三种情况&lt;/p&gt;</summary>
    
    
    
    
    <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty系列3——简易通信程序实例</title>
    <link href="http://yoursite.com/2020/09/30/netty_3_%E7%AE%80%E5%8D%95%E7%9A%84netty%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/09/30/netty_3_%E7%AE%80%E5%8D%95%E7%9A%84netty%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-09-30T03:03:41.000Z</published>
    <updated>2020-10-14T14:42:03.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="netty建议实例"><a href="#netty建议实例" class="headerlink" title="netty建议实例"></a>netty建议实例</h1><p>本章实现一个简单的netty的服务端和客户端，为后续阅读源码做准备</p><h3 id="1-功能点："><a href="#1-功能点：" class="headerlink" title="1.功能点："></a>1.功能点：</h3><ul><li>客户端向服务端发送“hello，服务端”</li><li>服务端回复“hello，客户端：xxxx”</li><li>提示连接与断开</li></ul><a id="more"></a><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><h4 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.example.chat.testForNIO.netty;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.*;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.ServerSocketChannel;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boosGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(boosGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture sync &#x3D; serverBootstrap.bind(6666).sync();</span><br><span class="line"></span><br><span class="line">            ChannelFuture sync1 &#x3D; sync.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            boosGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;工作处理器，结合模型可以看出，其实具体的逻辑处理是在pipeLine里面顺序处理完的</span><br><span class="line">package com.example.chat.testForNIO.netty;</span><br><span class="line"></span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line">import io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf byteBuf &#x3D; (ByteBuf)msg;</span><br><span class="line">        System.out.println(&quot;get Msg from client: &quot;+byteBuf.toString());</span><br><span class="line">        System.out.println(&quot;client address: &quot;+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;hello,cleint~&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2 客户端"></a>2.2 客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.example.chat.testForNIO.netty;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.EventLoop;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoop;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line"></span><br><span class="line">public class NettyClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EventLoopGroup eventLoop &#x3D; new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventLoop)</span><br><span class="line">                    .channel(SocketChannel.class)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            bootstrap.connect(&quot;127.0.0.1&quot;,6666);</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            eventLoop.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.example.chat.testForNIO.netty;</span><br><span class="line"></span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line">import io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line">public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello server&quot;, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf byteBuf &#x3D; (ByteBuf)msg;</span><br><span class="line">        System.out.println(&quot;get Msg from server: &quot;+byteBuf.toString());</span><br><span class="line">        System.out.println(&quot;server: &quot;+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;netty建议实例&quot;&gt;&lt;a href=&quot;#netty建议实例&quot; class=&quot;headerlink&quot; title=&quot;netty建议实例&quot;&gt;&lt;/a&gt;netty建议实例&lt;/h1&gt;&lt;p&gt;本章实现一个简单的netty的服务端和客户端，为后续阅读源码做准备&lt;/p&gt;
&lt;h3 id=&quot;1-功能点：&quot;&gt;&lt;a href=&quot;#1-功能点：&quot; class=&quot;headerlink&quot; title=&quot;1.功能点：&quot;&gt;&lt;/a&gt;1.功能点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;客户端向服务端发送“hello，服务端”&lt;/li&gt;
&lt;li&gt;服务端回复“hello，客户端：xxxx”&lt;/li&gt;
&lt;li&gt;提示连接与断开&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络(一)</title>
    <link href="http://yoursite.com/2020/08/29/internet-1/"/>
    <id>http://yoursite.com/2020/08/29/internet-1/</id>
    <published>2020-08-29T09:26:26.000Z</published>
    <updated>2020-10-11T11:55:55.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络学习笔记（一）——-应用层"><a href="#计算机网络学习笔记（一）——-应用层" class="headerlink" title="计算机网络学习笔记（一）—— 应用层"></a>计算机网络学习笔记（一）—— 应用层</h1><h1 id="五层网络模型"><a href="#五层网络模型" class="headerlink" title="五层网络模型"></a>五层网络模型</h1><ol><li><p>为什么要分成五层结构<br> 为了明确分工，网络系统本就是一个复杂的系统，如果没有明确的分层分工，就会出现高耦合的情况，牵一发而动全身<br> 但是如果进行了明确的分层，那么每层的协议相对独立，某一个层面协议调整不会影响整个过程，也方便扩展</p></li><li><p>具体是哪五层<br> 应用层：终端机直接操控接触的一层，是分布式的应用程序交互的通讯层，主要的协议有http，smtp，tcp（豹纹）<br>运输层：主要是在应用层的端口将报文组成报文段，传输给其他终端。主要的协议有tcp，udp（报文段）<br>网络层：主要是针对因特网，主要协议是IP（数据报）<br>链路层：略<br>物理层：略</p></li></ol>   <a id="more"></a><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><pre><code>通过完成在不同端系统的应用程序通信，不需要依赖网络核心设备（路由器，链路层交换机），就可以完成各种网络应用程序的部署和发展</code></pre><h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1 应用层协议原理"></a>1 应用层协议原理</h2><h3 id="1-1-网络应用程序体系结构"><a href="#1-1-网络应用程序体系结构" class="headerlink" title="1.1 网络应用程序体系结构"></a>1.1 网络应用程序体系结构</h3><ul><li>客服-服务器结构<ul><li>首先客户之间不能直接通信</li><li>必须具有中心化的服务器作</li><li>服务器具有固定，周知的地址（IP地址）</li><li>单台服务器可能无法支撑这种</li></ul></li><li>P2P<ul><li>对数据中心几乎没有依赖</li><li>自扩展性，下载数据的同时也可以上传数据，整体系统的服务能力得到增加</li></ul></li></ul><h3 id="1-2-进程间通信"><a href="#1-2-进程间通信" class="headerlink" title="1.2 进程间通信"></a>1.2 进程间通信</h3><ul><li>网络应用程序由成对的进程组成，这些进程通过网络互相发送报文。</li><li>客户端与服务端的定义：在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起于其他进程的联系）的进程被标示为客户，在会话时等待联系的进程时服务器  </li></ul><h3 id="1-3-进程与计算机网络之间的接口"><a href="#1-3-进程与计算机网络之间的接口" class="headerlink" title="1.3 进程与计算机网络之间的接口"></a>1.3 进程与计算机网络之间的接口</h3><ul><li>多数应用程序是由通信进程对组成，每对中两个进程互相发送报文，那么互相发送报文的通道是什么呢？  </li><li>*进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文,应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权**</li><li>一台网络进程是如何找到它想联系的进程的呢？<br>进程寻址：<br>  在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要一个地址。为了标识该接收进程，需要定义两种信息：<ol><li>主机的地址 </li><li>在墓地注重指定接受进程的标识</li></ol></li></ul><p><em>主机地址可以理解为IP地址，进程标识符可以理解为端口号这样就能解释通，为什么我们发送消息的时候，要IP+端口号一起。因为这样才能唯一识别我们需要的接口进程</em></p><h3 id="1-4-可供应用程序使用的服务运输"><a href="#1-4-可供应用程序使用的服务运输" class="headerlink" title="1.4 可供应用程序使用的服务运输"></a>1.4 可供应用程序使用的服务运输</h3><p>应用层端对运输层端的控制极少，但是也不是完全不能控制，我们可以选择运输层的运输协议（tcp/udp）<br><strong>因特网不只一种运输层协议，那就面临一个选择的问题，到底应该选择什么样的运输层协议才能满足我们的需求，然后就会引出另外一个问题，运输层协议应该具备哪些能力？</strong><br>所以我们首先了解一下一个运输层的协议应该为应用程序提供哪些能力，大体上可以分为四种能力：可靠数据传输，吞吐量，安全性，即时性  </p><ol><li>可靠数据传输<pre><code> 顾名思义，就是数据能够完整的，无偏差的传输给接收方。并不是所有的应用程序都需要做到完成可靠传输，有一些应用上允许数据丢失的，例如：流媒体，网络游戏。这种应用可以称之为“容忍丢失的应用”</code></pre></li><li>吞吐量<pre><code> 有些应用是带宽敏感的，你必须达到一定的码率才能满足要求，这种应用可以称之“带宽敏感的应用”。而“弹性应用”则对带宽的要求不是很高</code></pre></li><li>即时性<pre><code> 即延时高不高，有些应用需要低延时，例如网络游戏</code></pre></li><li>安全性<pre><code> 这个不用说了  </code></pre></li></ol><ul><li><strong>那么我们现有的运输协议是否具备上诉四种功能</strong>?<br> 目前因特网提供了两种运输层协议UDP和TCP:<ul><li>TCP： 面向连接，可靠的数据传送服务，有拥塞机制</li><li>UDP：没有连接，不会握手，不保证数据可靠性  </li></ul></li></ul><p>（注：无论是TCP还是UDP都没有提供任何加密机制，所以后面随着技术的发展，延伸出了SSL（安全套接字层））</p><ul><li>应用层协议<br> 应用层也有对应的通信协议，常见的有http，smtp，ftp等，应用层协议定义了允许在不同端系统上的应用程序进程如何相互传递报文，<strong>特别是应用层协议定义了</strong>：<ul><li>交换的报文类型，例如请求报文和相应报文</li><li>各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的</li><li>字段的语义，及这些字段的中的信息含义</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li></ul></li></ul><h2 id="2-web和HTTP"><a href="#2-web和HTTP" class="headerlink" title="2. web和HTTP"></a>2. web和HTTP</h2><h3 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h3><ol><li>http: 超文本传输协议（Hypertext Transfer protocol），是Web的应用层协议，它是web的核心。http由两个程序实现：一个客户端程序和一个服务器程序。两个程序运行在不同的端系统中，通过交换HTTP报文<br>进行会话。http定义了这些报文的格式以及双方交换报文的方式</li><li>一些术语：  <ol><li>web页面(Web page): 由对象组成的文档集合</li><li>对象（object）： 一个文件，例如一个HTML文件，一个JPEG图形，一个java小程序等这样的文件，他们可以通过YRL地址寻址</li><li>HTML基本文件：多数对象含有一个HTML文本以及几个引用对象</li><li>Web浏览器：http的客户端</li><li>web服务器：http的服务端</li><li>无状态协议：http服务器不会保存任何关于客户的信息，同一个客户对一个对象的多次请求，服务器不会因为客户的再一次请求而不做出反应</li></ol></li></ol><h3 id="2-2-非持续连接和持续连接"><a href="#2-2-非持续连接和持续连接" class="headerlink" title="2.2 非持续连接和持续连接"></a>2.2 非持续连接和持续连接</h3><ol><li>采用非持续连接的HTTP  <ul><li>什么是非持续链接： 每一个请求/响应对是经一个独立的TCP链接发送</li><li>非持续情况下，整个请求响应过程是怎样的？  <ul><li>当我们点击超链接时，实际是一次浏览器与web服务器的三次握手过程</li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: 挥手</span><br><span class="line">HTTP客户端-&gt;服务器: 发起TCP连接（syn&#x3D;1，seq&#x3D;x）</span><br><span class="line">服务器--&gt;HTTP客户端: 确认和响应（syn&#x3D;1，ack&#x3D;x+1，seq&#x3D;y）</span><br><span class="line">HTTP客户端-&gt;服务器: 返回确认（syn&#x3D;1，ack&#x3D;y+1,seq&#x3D;x+1）</span><br><span class="line">服务器--&gt;HTTP客户端: 文件传输</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">三次握手过程：</span><br><span class="line">（1）首先客户端向服务器端发送一段TCP报文，其中：</span><br><span class="line">    * 标记位为SYN，表示“请求建立新连接”;</span><br><span class="line">    * 序号为Seq&#x3D;X（X一般为1）；</span><br><span class="line">    * 随后客户端进入SYN-SENT阶段。</span><br><span class="line">（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</span><br><span class="line">    * 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</span><br><span class="line">    * 序号为Seq&#x3D;y；</span><br><span class="line">    * 确认号为Ack&#x3D;x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。</span><br><span class="line">（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</span><br><span class="line">    * 标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；</span><br><span class="line">    * 序号为Seq&#x3D;x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</span><br><span class="line">    * 确认号为Ack&#x3D;y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</span><br><span class="line">    * 客户端进入ESTABLISHED阶段。</span><br><span class="line"></span><br><span class="line">服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。</span><br><span class="line">在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续&quot;握手&quot;，以此确保了&quot;三次握手&quot;的顺利完成。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>采用持续连接的HTTP</p><ul><li><p>非持续链接的HTTP存在两个缺点</p><ul><li><p>必须为每一个请求的对象建立和维护一个连接，对于每一个这样的连接，客户端和服务器都要建立TCP缓存区</p></li><li><p>每一个对象都要经过两倍的RTT交付时延</p><p>（注：RTT（round-Trip Time）：一次请求的往返时间）</p></li></ul></li></ul></li></ol><p>​       对象的请求可以在一个连接上持续进行，不必等到对未决请求的回答</p><h3 id="2-3-HTTP报文格式"><a href="#2-3-HTTP报文格式" class="headerlink" title="2.3 HTTP报文格式"></a>2.3 HTTP报文格式</h3><ol><li><p>HTTP请求报文</p><p><img src="https://s1.ax1x.com/2020/09/14/wrPNqS.png" alt="httpRequest"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">GET &#x2F;somedir&#x2F;page.html HTTP&#x2F;1.1</span><br><span class="line">Host:www.someschle.com</span><br><span class="line">Connection:close</span><br><span class="line">User-agent: Mozila&#x2F;5.0</span><br><span class="line">Accept-language:fr</span><br></pre></td></tr></table></figure></li></ol><pre><code>  * http规定的请求方法有GET,POST,HEAD,PUT和DELETE，我们常用的就是get和post两种方法    * GET方法      GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始      这种方式不适合传送私密数据，需要传送大量数据的时候，也不适合使用GET方式    * POST方法      POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开  * 请求头部    * Host：请求的主机    * Connection：close   不要使用持续连接，发送完对象就断开    * User-agnet：浏览器类型    * Accept-Language：想得到的对象的语言版本  * 请求体    POST请求时会把参数放在请求体里面</code></pre><ol start="2"><li><p>HTTP响应报文</p><p><img src="https://s1.ax1x.com/2020/09/14/wrVLeP.png" alt="http响应报文"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">HTTP&#x2F;1.1 200 ok</span><br><span class="line">Connection:close</span><br><span class="line">Date:Tue,18 Aug 2015 15:44:04 GMT</span><br><span class="line">server:</span><br><span class="line">Last-modified:</span><br><span class="line">Content-Length:</span><br><span class="line">Content-Type:</span><br></pre></td></tr></table></figure><ul><li><p>状态行</p><p>协议版本没什么好说的，主要说一下状态码和状态码描述</p><ul><li>状态码是约定成俗的，我们不用记住所有的状态码，但是几个常见的还是要记住</li></ul><table><thead><tr><th align="center">状态码</th><th align="center">状态码描述</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">ok</td><td align="left">请求成功，信息中返回的响应报文中</td></tr><tr><td align="center">301</td><td align="center">moved permanently</td><td align="left">请求的对象被永久转移了，新的URL会在Location中显示，客户端会自动跳转</td></tr><tr><td align="center">400</td><td align="center">bad requst</td><td align="left">通用错误，该请求不能被服务器理解</td></tr><tr><td align="center">404</td><td align="center">not found</td><td align="left">未找到请求对象</td></tr><tr><td align="center">505</td><td align="center">Http version not support</td><td align="left">协议版本不支持</td></tr></tbody></table></li></ul></li></ol><pre><code>  * 响应头部    头部有几个重要的字段需要重点说一下    * Last-modified    * content-Length    * Content-Type  * 响应正文    响应正文的格式取决于content-type的格式，这里不做赘述，不过按照restful的标识，一般都采用json</code></pre><h3 id="2-4-用户与服务器的交互：cookie"><a href="#2-4-用户与服务器的交互：cookie" class="headerlink" title="2.4 用户与服务器的交互：cookie"></a>2.4 用户与服务器的交互：cookie</h3><ol><li>为什么需要cookie</li></ol><p>因为HTTP属于无状态的协议，就是说它不会记住每次请求的是谁，只关心每一次的请求内容。但是很多的web站点都需要能够标识用户（类似于淘宝这些），这样做有可能是为了限制客户访问，也有可能是为了把内容和用户绑定起来，反正就是要知道谁是谁。所以就诞生了cookie技术，目的就是跟踪用户</p><ol start="2"><li><p>cookie工作原理</p><ol><li><p>cookie技术一共由四个组建构成：</p><ul><li>在HTTP响应报文头里面的cookie首部行</li><li>在HTTP请求报文头里面的cookie首部行</li><li>在用户端存储了cookie文件</li><li>后端数据库</li></ul></li><li><p>工作原理 </p><p>如下图所示为cookie的工作原理：</p><p><img src="https://s1.ax1x.com/2020/09/17/wfNcjO.jpg" alt="cookie工作原理"></p><ul><li><p>我们以浏览器访问amazon网站为例，普通的http请求达到服务端后（假设之前已经登陆过ebay），服务端为其分配一个ID 1678，并在数据库中做存储操作</p></li><li><p>服务端返回http响应，并在头部设置字段Set-cookie：1678，传递给客户端</p></li><li><p>客户端拿到cookie信息后，在其本地管理的特定cookie文件中添加一行amazon：1678</p></li><li><p>客户端的后续请求中，把cookie：1678作为请求头的一个字段，每次都带过来</p></li><li><p>这样服务器虽然不知道用户是哪个人，但是它知道cookie为1678的用户的个人信息，访问顺序，访问时间，访问内容等状态信息，服务端可以根据记录的用户状态进行特定的动作</p></li></ul><p>总结：cookie使得在无状态的http之上建立一个会话层成为可能</p></li></ol></li><li><p>cookie的弊端</p><ul><li>对用户的隐私造成了侵害，不法者可以拦截篡改cookie，如果被拦截就能获取所有的session信息</li><li>部分浏览器有cookie数量限制，每个cookie的长度不超过4k，否则会被截掉</li><li>有些状态不可能保存在客户端，例如：表单重复提交，为了防止这种情况，会在服务端维持一个计数器，如果这个计数器在客户端将毫无意义</li></ul></li></ol><h3 id="2-5-Web缓存"><a href="#2-5-Web缓存" class="headerlink" title="2.5 Web缓存"></a>2.5 Web缓存</h3><ol><li><p>什么是web缓存</p><p>web缓存器又叫 代理服务器，为例减轻初始服务器的压力而专门构建的。</p></li><li><p>为什么需要web缓存？</p><ul><li>对于机构组织来说，访问内部服务器肯定要比访问公网的要快，可以提升速度</li><li>机构组织人员如果能在内网缓存获得想要的内容，那么就能降低这个机构访问公网的带宽负担</li></ul></li><li><p>web缓存的工作原理</p><p>当我们通过web缓存器的方式访问资源的时候，会发生以下事情：</p><ul><li>我们的浏览器与web缓存器建立TCP连接，并发送一个HTTP请求，请求资源对象</li><li>web缓存器收到HTTP请求以后，在本地查看是否存储了该资源对象，如果有则HTTP响应返回该对象</li><li>如果本地没有该对象，缓存器则去原服务器请求求该对象。</li><li>从原服务器请求到该对象以后，首先在web缓存器端存一份副本，然后再在HTTP响应中返回该副本对象</li></ul></li></ol><h2 id="4-DNS：因特网的目录服务"><a href="#4-DNS：因特网的目录服务" class="headerlink" title="4. DNS：因特网的目录服务"></a>4. DNS：因特网的目录服务</h2><p>为什么需要DNS？</p><p>你如何记住一个地址？如果给你一串数字，是不是很不好记忆，但是如果给你一个英文的地名，是不是就变得很好记忆里。</p><p>我们把用英文字母来作为地址的标识方式成为主机名（hostname），由一串数字组成的地址称为IP地址，人类喜欢用hostname，但是对电脑来说，ip地址跟易识别。为了两者折衷，所以我们需要一种能进行主机名到IP地址转换的目录服务，这就是DNS的主要任务。</p><ol><li><p>DNS提供的服务</p><ol><li><p>DNS属于应用层协议，UDP传输，端口为53</p></li><li><p>DNS由以下部分组成：</p><ul><li>一个分层的DNS服务器实现的**<em>分布式数据库**</em></li><li>一个使得主机能够查询分布式数据库的**<em>应用协议**</em></li></ul></li><li><p>由于完整的DNS查询会带来更多的延时，所以我们可以考虑在一个“附近的”DNS中加缓存，这样有助于降低流量和DNS的平均延时</p></li><li><p>除了主机名到IP地址的转换，DNS还提供了一些重要的服务</p><ul><li><p>主机别名</p><p>规范主机名有时候比较难记忆，所以我们可以给主机起别名，便于记忆，应用程序是可以通过调用DNS来获得别名的规范主机名和IP地址的</p></li><li><p>邮件服务器别名</p><p>同上，便于记忆</p></li><li><p>负载分配</p><p>多个IP地址同一个规范主机名相关联，我们在请求访问时，DNS会进行负载分配决定由哪个IP来响应。</p></li></ul></li></ol></li><li><p>DNS工作机理概述</p><p>这里说的工作机理主要是指主机名到IP地址转换方面的原理</p><pre><code>    1. DNS的架构设计——集中式</code></pre><p>​        假设只有一个DNS服务器，所有的映射都存在上面，它接受所有的请求并响应，那么忧郁全球网络巨大的流量，这种集中式的设计将带来以下问题：</p><p>​        （1）单点故障：DNS奔溃，意味着全球断网</p><p>​        （2）通信容量：它将处理所有的DNS查询</p><p>​        （3）远距离的集中式数据库：假设这个数据库在纽约，那么横跨半个地球的澳大利亚的请求，将经历巨大的时延</p><p>​        （4）维护：数据太多，维护异常艰难</p><p>​       综上所述，集中式的DNS服务器架构是没有可扩展性的，所以只能通过分布式的方式设计数据库</p><p>​       </p><ol start="2"><li><p>DNS的架构设计——分布式，层次数据库</p><p>为了处理扩展性的问题，DNS采用了分层式的方式组织服务器，服务器分布于全球，大致上来说全球的DNS服务器可以分为三种类型：</p><ol><li>根DNS服务器</li><li>顶级域DNS服务器</li><li>权威DNS服务器</li></ol><p>三种DNS服务器的组织方式如下图所示：</p><p><img src="https://s1.ax1x.com/2020/09/20/wTBPC8.jpg" alt="DNS架构图"></p><p>严格来说，还有一类比较重要的DNS服务器，我们称之为本地DNS服务器</p></li><li><p>工作原理如下图所示，已经非常清楚了，就不重复了文字了</p></li></ol></li></ol><p><img src="https://s1.ax1x.com/2020/09/20/wTYnqf.png" alt="DNS工作流程图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络学习笔记（一）——-应用层&quot;&gt;&lt;a href=&quot;#计算机网络学习笔记（一）——-应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络学习笔记（一）—— 应用层&quot;&gt;&lt;/a&gt;计算机网络学习笔记（一）—— 应用层&lt;/h1&gt;&lt;h1 id=&quot;五层网络模型&quot;&gt;&lt;a href=&quot;#五层网络模型&quot; class=&quot;headerlink&quot; title=&quot;五层网络模型&quot;&gt;&lt;/a&gt;五层网络模型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么要分成五层结构&lt;br&gt; 为了明确分工，网络系统本就是一个复杂的系统，如果没有明确的分层分工，就会出现高耦合的情况，牵一发而动全身&lt;br&gt; 但是如果进行了明确的分层，那么每层的协议相对独立，某一个层面协议调整不会影响整个过程，也方便扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体是哪五层&lt;br&gt; 应用层：终端机直接操控接触的一层，是分布式的应用程序交互的通讯层，主要的协议有http，smtp，tcp（豹纹）&lt;br&gt;运输层：主要是在应用层的端口将报文组成报文段，传输给其他终端。主要的协议有tcp，udp（报文段）&lt;br&gt;网络层：主要是针对因特网，主要协议是IP（数据报）&lt;br&gt;链路层：略&lt;br&gt;物理层：略&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网络技术基础" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【第一篇】建立自己的知识体系</title>
    <link href="http://yoursite.com/2020/08/18/method_learn_1/"/>
    <id>http://yoursite.com/2020/08/18/method_learn_1/</id>
    <published>2020-08-18T11:20:06.000Z</published>
    <updated>2020-10-11T11:55:56.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识体系建立计划"><a href="#知识体系建立计划" class="headerlink" title="知识体系建立计划"></a>知识体系建立计划</h1><p>​    俗话说的好，凡事预则立不预则废，如何让自己不被难题所困，重要的还是要建立知识体系，经过一个多月的计划，现将建立计划的过程记录下来.</p><h2 id="Step1-组建框架脉络"><a href="#Step1-组建框架脉络" class="headerlink" title="Step1:组建框架脉络"></a>Step1:组建框架脉络</h2><p>首先结合自己的生活和工作目标，以终为始。</p><ol><li><p>工作</p><ul><li><strong>计算机技术</strong>：提升自己的<strong>IT技术</strong>是必须的，这是吃饭的家伙，从前端到后端，整个大的框架都需要提升，这点没得说。优先级最高</li><li><strong>管理类知识</strong>：还是有想往上走的意愿，所以管理类的知识也要行夯实，这点是为可能的蜕变做准备。优先级较高</li></ul></li><li><p>生活</p><ul><li><strong>基础学科知识</strong>：高三可以说是一个基础学科的巅峰事情，现在很多<strong>基础学科知识</strong>已经忘光了，由于后面要<strong>辅导贝贝的功课</strong>，同时自己也想要提升，所以相关工作需要持续进行，优先级中</li><li><strong>扩展知识</strong>：生活要去发现有情趣的东西，人类文明几千年，有太多的东西可以去看，丰富自己的知识边界，既可以提高自己的眼界，也可提丰富自己的精神世界</li></ul></li></ol><p>   综上所述，可以归类成四个大的知识领域，这四个领域基本可以组成自己的认知世界，有句话说的好：“你只能看到你认为的世界的样子”，所以努力提高知识边界，才能让自己活得精彩</p><p>​    同时，每个大的知识领域下都有很多细分的小领域，需要注意的是，这些被细分出来的小领域，并不能绝对的认为是该领域的客观全貌。每个小领域下面有分成了许多的独立知识点，这些小领域和知识点根据一定的逻辑来进行排列划分的。</p><p>​    所谓的知识体系，其实一句话概括就是：各种无序的知识点的有序结构排列结果。只要结构化没问题，最终的效果一定不会差</p><a id="more"></a><h2 id="Step2-填充各领域细节"><a href="#Step2-填充各领域细节" class="headerlink" title="Step2:填充各领域细节"></a>Step2:填充各领域细节</h2><p>在确定了大的领域方向以后，我们需要对每个领域所包含的小领域进行填充，值得注意的是，同一个大领域的小领域也是要按照一定的逻辑顺序来排列的先后的，这样才符合知识体系的定义，而且有逻辑的组合也方便记忆</p><ol><li><p>计算机技术领域</p><p>该领域下的知识点的逻辑性还是挺强的，这里我按照自己的思维进行了排列，思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>管理类知识领域</li></ol><h2 id="Step3-执行计划"><a href="#Step3-执行计划" class="headerlink" title="Step3: 执行计划"></a>Step3: 执行计划</h2><h2 id="Step4-定期回顾"><a href="#Step4-定期回顾" class="headerlink" title="Step4: 定期回顾"></a>Step4: 定期回顾</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;知识体系建立计划&quot;&gt;&lt;a href=&quot;#知识体系建立计划&quot; class=&quot;headerlink&quot; title=&quot;知识体系建立计划&quot;&gt;&lt;/a&gt;知识体系建立计划&lt;/h1&gt;&lt;p&gt;​    俗话说的好，凡事预则立不预则废，如何让自己不被难题所困，重要的还是要建立知识体系，经过一个多月的计划，现将建立计划的过程记录下来.&lt;/p&gt;
&lt;h2 id=&quot;Step1-组建框架脉络&quot;&gt;&lt;a href=&quot;#Step1-组建框架脉络&quot; class=&quot;headerlink&quot; title=&quot;Step1:组建框架脉络&quot;&gt;&lt;/a&gt;Step1:组建框架脉络&lt;/h2&gt;&lt;p&gt;首先结合自己的生活和工作目标，以终为始。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;计算机技术&lt;/strong&gt;：提升自己的&lt;strong&gt;IT技术&lt;/strong&gt;是必须的，这是吃饭的家伙，从前端到后端，整个大的框架都需要提升，这点没得说。优先级最高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理类知识&lt;/strong&gt;：还是有想往上走的意愿，所以管理类的知识也要行夯实，这点是为可能的蜕变做准备。优先级较高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生活&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基础学科知识&lt;/strong&gt;：高三可以说是一个基础学科的巅峰事情，现在很多&lt;strong&gt;基础学科知识&lt;/strong&gt;已经忘光了，由于后面要&lt;strong&gt;辅导贝贝的功课&lt;/strong&gt;，同时自己也想要提升，所以相关工作需要持续进行，优先级中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展知识&lt;/strong&gt;：生活要去发现有情趣的东西，人类文明几千年，有太多的东西可以去看，丰富自己的知识边界，既可以提高自己的眼界，也可提丰富自己的精神世界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;   综上所述，可以归类成四个大的知识领域，这四个领域基本可以组成自己的认知世界，有句话说的好：“你只能看到你认为的世界的样子”，所以努力提高知识边界，才能让自己活得精彩&lt;/p&gt;
&lt;p&gt;​    同时，每个大的知识领域下都有很多细分的小领域，需要注意的是，这些被细分出来的小领域，并不能绝对的认为是该领域的客观全貌。每个小领域下面有分成了许多的独立知识点，这些小领域和知识点根据一定的逻辑来进行排列划分的。&lt;/p&gt;
&lt;p&gt;​    所谓的知识体系，其实一句话概括就是：各种无序的知识点的有序结构排列结果。只要结构化没问题，最终的效果一定不会差&lt;/p&gt;</summary>
    
    
    
    
    <category term="方法论" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
</feed>
